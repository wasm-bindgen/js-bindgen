use std::mem;

use proc_macro2::TokenStream;
use syn::{Error, File, Item, ItemMod, Meta, Path, Result, parse_quote};

use crate::ImportManager;
use crate::r#macro::{self, ErrorStack};

pub fn file(input: &str, crate_: &str, js_sys: Option<Path>) -> Result<File> {
	let mut file: File = syn::parse_str(input)?;
	let mut imports = ImportManager::new(js_sys);
	let mut error = ErrorStack::new();
	process_items(
		mem::take(&mut file.items),
		&mut file.items,
		crate_,
		&mut imports,
		&mut error,
	);

	file.items = imports.iter().map(Item::from).chain(file.items).collect();

	file.attrs = [
		parse_quote!(#![doc = " This file was generated by `js-sys-bindgen`."]),
		parse_quote!(#![allow(warnings)]),
	]
	.into_iter()
	.chain(file.attrs)
	.collect();

	if let Some(error) = error.resolve() {
		Err(error)
	} else {
		Ok(file)
	}
}

fn process_items(
	items: Vec<Item>,
	output: &mut Vec<Item>,
	crate_: &str,
	imports: &mut ImportManager,
	error: &mut ErrorStack,
) {
	for item in items {
		match item {
			item @ (Item::ExternCrate(_) | Item::Use(_)) => output.push(item),
			Item::ForeignMod(mut foreign_mod) => {
				let js_sys = foreign_mod
					.attrs
					.extract_if(.., |attr| attr.path().is_ident("js_sys"))
					.next();

				if let Some(js_sys) = js_sys {
					let attr = match js_sys.meta {
						Meta::Path(_) => TokenStream::new(),
						Meta::List(list) => list.tokens,
						Meta::NameValue(name_value) => {
							error.push(Error::new_spanned(
								name_value,
								"found unsupported `js_sys` attribute syntax",
							));
							continue;
						}
					};

					match r#macro::internal(attr, foreign_mod, Some(crate_), Some(imports)) {
						Ok(mut items) => output.append(&mut items),
						Err((_, e)) => {
							error.push(e);
						}
					}
				} else {
					error.push(Error::new_spanned(
						foreign_mod,
						"`js_sys` attribute not found",
					));
				}
			}
			Item::Mod(
				mut r#mod @ ItemMod {
					content: Some(_), ..
				},
			) => {
				let items = &mut r#mod.content.as_mut().unwrap().1;
				process_items(mem::take(items), items, crate_, imports, error);
				output.push(r#mod.into());
			}
			item => error.push(Error::new_spanned(item, "item not supported")),
		}
	}
}
