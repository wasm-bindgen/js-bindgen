//! This program generates the LLD options we require to parse LLD arguments.
//!
//! The input is a `options.json` file produced by running:
//! ```sh
//! llvm-tblgen --dump-json lld/wasm/Options.td -o options.json -I llvm/include
//! ```
//!
//! Then you can run this program:
//! ```sh
//! cargo run -p lld-opt -- <path to your `options.json`>
//! ```

use std::collections::BTreeMap;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use std::{env, fs};

use anyhow::Result;
use proc_macro2::Span;
use quote::quote;
use serde_json::Value;
use syn::{Ident, LitByteStr};

fn main() -> Result<()> {
	let opt_table: BTreeMap<String, Value> = serde_json::from_slice(&fs::read(
		env::args_os().nth(1).expect("pass path to `options.json`"),
	)?)?;
	let mut args = Vec::new();

	for option in opt_table.values() {
		if let Some(name) = option.get("Name").and_then(|n| n.as_str())
			&& let Some(kind) = option
				.get("Kind")
				.and_then(|def| def.get("def"))
				.and_then(|s| s.as_str())
		{
			// We don't want to handle those.
			if kind == "KIND_INPUT" || kind == "KIND_UNKNOWN" {
				continue;
			}

			args.push((name, kind));
		}
	}

	let length = args.len();
	let arg_name = args
		.iter()
		.map(|(name, _)| LitByteStr::new(name.as_bytes(), Span::call_site()));
	let arg_flag = args
		.iter()
		.map(|(_, flag)| Ident::new(flag, Span::call_site()));

	let output = quote! {
		static OPT_KIND: [(&[u8], OptKind); #length] = [
			#((#arg_name, OptKind::#arg_flag)),*
		];
	};
	let output = syn::parse2(output)?;
	let output = prettyplease::unparse(&output);

	let root = env::var_os("CARGO_MANIFEST_DIR").unwrap();
	let root = Path::new(&root);
	let mut ouput_file = File::create(
		root.parent()
			.unwrap()
			.join("linker")
			.join("src")
			.join("lld-opt.rs"),
	)?;
	writeln!(ouput_file, "// Generated by `lld-opt`.\n\n{output}")?;
	ouput_file.sync_all()?;

	Ok(())
}
