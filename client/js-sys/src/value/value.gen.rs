//! This file was generated by `js-sys-bindgen`.
#![allow(warnings)]
use crate::{js_bindgen, r#macro};
use crate::hazard::{Input, Output};
use super::JsValue;
use crate::util::PtrLength;
pub(super) fn js_value_partial_eq(value1: &JsValue, value2: &JsValue) -> bool {
    js_bindgen::unsafe_embed_asm! {
        ".import_module js_sys.import.js_value_partial_eq, js_sys",
        ".import_name js_sys.import.js_value_partial_eq, js_value_partial_eq",
        ".functype js_sys.import.js_value_partial_eq ({}, {}) -> ({})", "", "{}", "",
        "{}", "", ".globl js_sys.js_value_partial_eq", "js_sys.js_value_partial_eq:",
        "\t.functype js_sys.js_value_partial_eq ({}, {}) -> ({})", "\tlocal.get 0",
        "\t{}", "\tlocal.get 1", "\t{}", "\tcall js_sys.import.js_value_partial_eq",
        "\t{}", "\tend_function", interpolate < & JsValue as Input > ::ASM_IMPORT_TYPE,
        interpolate < & JsValue as Input > ::ASM_IMPORT_TYPE, interpolate < bool as
        Output > ::ASM_IMPORT_TYPE, interpolate r#macro::asm_import!(& JsValue as Input),
        interpolate r#macro::asm_import!(bool as Output), interpolate < & JsValue as
        Input > ::ASM_TYPE, interpolate < & JsValue as Input > ::ASM_TYPE, interpolate <
        bool as Output > ::ASM_TYPE, interpolate r#macro::asm_conv!(& JsValue as Input),
        interpolate r#macro::asm_conv!(& JsValue as Input), interpolate
        r#macro::asm_conv!(bool as Output),
    }
    js_bindgen::import_js! {
        module = "js_sys", name = "js_value_partial_eq", required_embeds = [("js_sys",
        "js_value.partial_eq"), r#macro::js_import!(& JsValue as Input),
        r#macro::js_import!(bool as Output)], "{}{}{}{}", interpolate
        r#macro::js_select!("", "(value1, value2) => {\n", [& JsValue], bool),
        interpolate r#macro::js_parameter!("value1", & JsValue), interpolate
        r#macro::js_parameter!("value2", & JsValue), interpolate
        r#macro::js_output!("\treturn ", "this.#jsEmbed.js_sys['js_value.partial_eq']",
        "this.#jsEmbed.js_sys['js_value.partial_eq'](value1, value2)", bool, & JsValue),
    }
    unsafe extern "C" {
        #[link_name = "js_sys.js_value_partial_eq"]
        fn js_value_partial_eq(
            value1: <&JsValue as Input>::Type,
            value2: <&JsValue as Input>::Type,
        ) -> <bool as Output>::Type;
    }
    Output::from_raw(unsafe {
        js_value_partial_eq(Input::into_raw(value1), Input::into_raw(value2))
    })
}
