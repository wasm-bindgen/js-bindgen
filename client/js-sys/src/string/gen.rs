//! This file was generated by `js-sys-bindgen`.
#![allow(warnings)]
use core::ops::Deref;
use crate::{js_bindgen, r#macro, JsValue};
use crate::hazard::{Input, Output};
use crate::util::PtrLength;
#[repr(transparent)]
pub struct JsString(JsValue);
impl Deref for JsString {
    type Target = JsValue;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl From<JsString> for JsValue {
    fn from(value: JsString) -> Self {
        value.0
    }
}
unsafe impl Input for &JsString {
    const IMPORT_FUNC: &'static str = <&JsValue as Input>::IMPORT_FUNC;
    const IMPORT_TYPE: &'static str = <&JsValue as Input>::IMPORT_TYPE;
    const TYPE: &'static str = <&JsValue as Input>::TYPE;
    const CONV: &'static str = <&JsValue as Input>::CONV;
    type Type = <&'static JsValue as Input>::Type;
    fn into_raw(self) -> Self::Type {
        Input::into_raw(&self.0)
    }
}
unsafe impl Output for JsString {
    const IMPORT_FUNC: &str = <JsValue as Output>::IMPORT_FUNC;
    const IMPORT_TYPE: &str = <JsValue as Output>::IMPORT_TYPE;
    const TYPE: &str = <JsValue as Output>::TYPE;
    const CONV: &str = <JsValue as Output>::CONV;
    type Type = <JsValue as Output>::Type;
    fn from_raw(raw: Self::Type) -> Self {
        Self(Output::from_raw(raw))
    }
}
impl JsString {
    #[must_use]
    pub fn unchecked_from(value: JsValue) -> Self {
        Self(value)
    }
}
pub(super) fn string_decode(array: *const u8, len: PtrLength) -> JsString {
    js_bindgen::unsafe_embed_asm! {
        ".import_module js_sys.import.string_decode, js_sys",
        ".import_name js_sys.import.string_decode, string_decode",
        ".functype js_sys.import.string_decode ({}, {}) -> ({})", "", "{}", "", "{}", "",
        "{}", "", ".globl js_sys.string_decode", "js_sys.string_decode:",
        "\t.functype js_sys.string_decode ({}, {}) -> ({})", "\tlocal.get 0", "\t{}",
        "\tlocal.get 1", "\t{}", "\tcall js_sys.import.string_decode", "\t{}",
        "\tend_function", interpolate < * const u8 as Input > ::IMPORT_TYPE, interpolate
        < PtrLength as Input > ::IMPORT_TYPE, interpolate < JsString as Output >
        ::IMPORT_TYPE, interpolate < * const u8 as Input > ::IMPORT_FUNC, interpolate <
        PtrLength as Input > ::IMPORT_FUNC, interpolate < JsString as Output >
        ::IMPORT_FUNC, interpolate < * const u8 as Input > ::TYPE, interpolate <
        PtrLength as Input > ::TYPE, interpolate < JsString as Output > ::TYPE,
        interpolate < * const u8 as Input > ::CONV, interpolate < PtrLength as Input >
        ::CONV, interpolate < JsString as Output > ::CONV,
    }
    js_bindgen::import_js! {
        name = "string_decode", required_embed = "string.decode", "{}{}{}{}{}{}{}{}",
        interpolate r#macro::select("this.#jsEmbed.js_sys['string.decode']",
        "(array, len) => {\n", [< * const u8 as Input > ::JS_CONV, < PtrLength as Input >
        ::JS_CONV]), interpolate r#macro::select("", "\tarray", [< * const u8 as Input >
        ::JS_CONV]), interpolate r#macro::select("", < * const u8 as Input > ::JS_CONV,
        [< * const u8 as Input > ::JS_CONV]), interpolate r#macro::select("", "\n", [< *
        const u8 as Input > ::JS_CONV]), interpolate r#macro::select("", "\tlen", [<
        PtrLength as Input > ::JS_CONV]), interpolate r#macro::select("", < PtrLength as
        Input > ::JS_CONV, [< PtrLength as Input > ::JS_CONV]), interpolate
        r#macro::select("", "\n", [< PtrLength as Input > ::JS_CONV]), interpolate
        r#macro::select("",
        "\treturn this.#jsEmbed.js_sys['string.decode'](array, len)\n}", [< * const u8 as
        Input > ::JS_CONV, < PtrLength as Input > ::JS_CONV]),
    }
    unsafe extern "C" {
        #[link_name = "js_sys.string_decode"]
        fn string_decode(
            array: <*const u8 as Input>::Type,
            len: <PtrLength as Input>::Type,
        ) -> <JsString as Output>::Type;
    }
    Output::from_raw(unsafe {
        string_decode(Input::into_raw(array), Input::into_raw(len))
    })
}
