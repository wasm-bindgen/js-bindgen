//! This file was generated by `js-sys-bindgen`.
#![allow(warnings)]
use core::marker::PhantomData;
use core::ops::Deref;
use crate::{js_bindgen, r#macro, JsValue};
use crate::hazard::{Input, Output};
use crate::util::PtrLength;
#[repr(transparent)]
pub struct JsArray<T = JsValue> {
    value: JsValue,
    _type: PhantomData<T>,
}
impl<T> Deref for JsArray<T> {
    type Target = JsValue;
    fn deref(&self) -> &Self::Target {
        &self.value
    }
}
impl<T> From<JsArray<T>> for JsValue {
    fn from(value: JsArray<T>) -> Self {
        value.value
    }
}
unsafe impl<T> Input for &JsArray<T> {
    const IMPORT_FUNC: &'static str = <&JsValue as Input>::IMPORT_FUNC;
    const IMPORT_TYPE: &'static str = <&JsValue as Input>::IMPORT_TYPE;
    const TYPE: &'static str = <&JsValue as Input>::TYPE;
    const CONV: &'static str = <&JsValue as Input>::CONV;
    type Type = <&'static JsValue as Input>::Type;
    fn into_raw(self) -> Self::Type {
        Input::into_raw(&self.value)
    }
}
unsafe impl<T> Output for JsArray<T> {
    const IMPORT_FUNC: &str = <JsValue as Output>::IMPORT_FUNC;
    const IMPORT_TYPE: &str = <JsValue as Output>::IMPORT_TYPE;
    const TYPE: &str = <JsValue as Output>::TYPE;
    const CONV: &str = <JsValue as Output>::CONV;
    type Type = <JsValue as Output>::Type;
    fn from_raw(raw: Self::Type) -> Self {
        Self {
            value: Output::from_raw(raw),
            _type: PhantomData,
        }
    }
}
impl<T> JsArray<T> {
    #[must_use]
    pub fn unchecked_from(value: JsValue) -> Self {
        Self { value, _type: PhantomData }
    }
}
pub(super) fn array_u32_decode(array: *const u32, len: PtrLength) -> JsArray<u32> {
    js_bindgen::unsafe_embed_asm! {
        ".import_module js_sys.import.array_u32_decode, js_sys",
        ".import_name js_sys.import.array_u32_decode, array_u32_decode",
        ".functype js_sys.import.array_u32_decode ({}, {}) -> ({})", "", "{}", "", "{}",
        "", "{}", "", ".globl js_sys.array_u32_decode", "js_sys.array_u32_decode:",
        "\t.functype js_sys.array_u32_decode ({}, {}) -> ({})", "\tlocal.get 0", "\t{}",
        "\tlocal.get 1", "\t{}", "\tcall js_sys.import.array_u32_decode", "\t{}",
        "\tend_function", interpolate < * const u32 as Input > ::IMPORT_TYPE, interpolate
        < PtrLength as Input > ::IMPORT_TYPE, interpolate < JsArray < u32 > as Output >
        ::IMPORT_TYPE, interpolate < * const u32 as Input > ::IMPORT_FUNC, interpolate <
        PtrLength as Input > ::IMPORT_FUNC, interpolate < JsArray < u32 > as Output >
        ::IMPORT_FUNC, interpolate < * const u32 as Input > ::TYPE, interpolate <
        PtrLength as Input > ::TYPE, interpolate < JsArray < u32 > as Output > ::TYPE,
        interpolate < * const u32 as Input > ::CONV, interpolate < PtrLength as Input >
        ::CONV, interpolate < JsArray < u32 > as Output > ::CONV,
    }
    js_bindgen::import_js! {
        name = "array_u32_decode", required_embed = "array.u32.decode",
        "{}{}{}{}{}{}{}{}", interpolate
        r#macro::select("this.#jsEmbed.js_sys['array.u32.decode']",
        "(array, len) => {\n", [< * const u32 as Input > ::JS_CONV, < PtrLength as Input
        > ::JS_CONV]), interpolate r#macro::select("", "\tarray", [< * const u32 as Input
        > ::JS_CONV]), interpolate r#macro::select("", < * const u32 as Input >
        ::JS_CONV, [< * const u32 as Input > ::JS_CONV]), interpolate r#macro::select("",
        "\n", [< * const u32 as Input > ::JS_CONV]), interpolate r#macro::select("",
        "\tlen", [< PtrLength as Input > ::JS_CONV]), interpolate r#macro::select("", <
        PtrLength as Input > ::JS_CONV, [< PtrLength as Input > ::JS_CONV]), interpolate
        r#macro::select("", "\n", [< PtrLength as Input > ::JS_CONV]), interpolate
        r#macro::select("",
        "\treturn this.#jsEmbed.js_sys['array.u32.decode'](array, len)\n}", [< * const
        u32 as Input > ::JS_CONV, < PtrLength as Input > ::JS_CONV]),
    }
    unsafe extern "C" {
        #[link_name = "js_sys.array_u32_decode"]
        fn array_u32_decode(
            array: <*const u32 as Input>::Type,
            len: <PtrLength as Input>::Type,
        ) -> <JsArray<u32> as Output>::Type;
    }
    Output::from_raw(unsafe {
        array_u32_decode(Input::into_raw(array), Input::into_raw(len))
    })
}
